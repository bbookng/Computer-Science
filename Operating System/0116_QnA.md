## 0116

#### 1. 프로세스에 스레드가 너무 많이 생기면 어떤 문제가 발생하는가 ?

스레드란 프로세스 내에서 실행되는 작업 흐름의 단위다.
메모리위에 올라가 있는 프로세스를 효율적으로 처리하기 위해 스레드를 사용한다.

스레드의 개수가 많아지면 스택에 차지하는 메모리가 많아지고, pcb 안에 tcb가 많아지고, context가 일어날 때 compare 할 게 많아지고, 운영체제에 부담이 커진다. 

아무리 개수가 많아도 코어의 개수 만큼만 돌아가고 나머지는 대기하고 있기 때문에 오버헤드 때문에 느려진다. 

#### 2. 가상 메모리에 대해 설명해주세요.

실제 메모리 크기와 상관 없이 메모리를 이용할 수 있도록 가상의 메모리 주소를 사용하는 방법이다. 

가상 메모리를 사용하면 보조 기억 장치 공간을 사용하여 실제 메모리(RAM) 크기 보다 더 큰 공간을 사용할 수 있고, 가상의 주소 공간을 사용하여 논리적인 연속성을 제공해준다. 또한 물리 메모리 주소 공간을 알 필요가 없어진다. 

대표적인 가상 메모리 기법으로 페이징과 세그멘테이션이 있다.

페이징이란 고정 크기로 분할된 페이지를 통해 가상 메모리를 관리하는 기법이다. 

요구 페이징이란 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 올리는 방식이다. 요구 페이징 기법에서는 특정 페이지에 대해 CPU 의 요청이 들어온 후에야 해당 페이지를 메모리에 적재한다. 

요구 페이징 기법에서는 당장 실행에 필요한 페이지만을 메모리에 적재하기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드도 줄어든다. 이는 사용되지 않을 주소 영역에 대한 입출력까지 수행하던 기존 방식에 비해 응답시간을 단축시킬 수 있으며, 시스템이 더 많은 프로세스를 수용할 수 있게 해준다. 또한 요구 페이징 기법의 주된 효용은 프로그램이 물리적 메모리의 용량 제약을 벗어날 수 있도록 한다. 

**페이지 교체 정책**

- 운영체제가 특정 페이지를 물리 메모리에 올리려고 하는데 물리 메모리가 다 차있다면 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고 새로운 페이지를 해당 물리 메모리 공간에 올려야 한다. 이 때 어떤 페이지를 물리 메모리에서 저장 매체로 내릴 것인가에 대한 것이다.

1. FIFO 

   - 가장 먼저 들어온 페이지를 내린다.

2. Optimal 

   - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다 > 그러나 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서 구현 불가

3. LRU (Least Recently Used)

   - 가장 오래 전에 사용된 페이지를 내리자. 

4. LFU (Least Frequently Used)

   - 가장 적게 사용된 페이지를 내리자.

5. NUR (Not Used Recently)

   

https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4



```
가상메모리 장점은? 단점은?
더 많은 공간을 위해서 사용한다면, 하드웨어가 좋아지면 가상메모리를 사용하지 않아도 되겠네요?


왜 쓰는가?
주어진 공간보다 더 많은 공간가능
조각화된 공간 사용 가능
불필요한 코드 복사 줄이기(서로 다른 프로세스에서 같은 주소를 사용)
데이터 보안에 유리 (다른 프로세스의 메모리를 알아내거나 접근하는 것을 방지)

사용하지 않을 경우 각 프로그램에 대해서, 함수가 어느 물리적 주소를 사용할지 하드코딩해야함. 그런데 만약 두 프로그램이 사용하는 주소가 겹칠 가능성이 있다면 충돌이 발생하니까 같이 못돌림. 가상메모리를 쓰면 같은 공간을 써도 다른 시간에 돌리므로 괜찮음. (안쓰는 동안 내려놓을 수 있다는 말) 같은 이유로, 어느 프로그램에서 에러가 난다면 그 주소를 계속 못쓰게 되므로 재부팅을 해야함. 하지만 가상메모리를 사용하면 해당 부분을 OS가 직접 들어내고 재사용 가능




단점
느리다. (그러나 하드웨어가 좋아지면서 극복 중)
디스크의 수명을 깎는다
```





#### 3. 안드로이드와 윈도우의 차이

- 안드로이드는 모바일에 최적화된 운영체제 
- 모바일 or PC 등의 질문을 할 수 있음. 



#### 4. 문맥 교환 (context switching) 과 오버헤드의 관계

- 문맥 교환이란 CPU에서 프로세스에서 프로세스로 교환하는 것을 말한다. 문맥을 교환하는 동안에는 유용한 작업을 수행할 수 없기 때문에, 문맥 교환 시간은 일종의 오버헤드라고 할 수 있다.  정확히는 기존의 프로세스가 해지 되는 순간부터 다음 프로세스가 적재되는 까지의 시간이다.
- 오버헤드가 중요한 이유는 문맥 교환이 진행되는 동안 시스템이 일을 하지 못하기 때문이다. 이 시간은 하드웨어의 성능이나 지원 정도에 따라 크게 달라지는데 레지스터 집합을 지원하는 처리기의 경우에는 집합에 대한 포인터만 저장, 재적재를 하면 되기 때문에 오버헤드가 크게 감소할 수 있다. 
- 문맥 교환을 통하여 교환 속도가 빨라서 사용자는 마치 여러가지의 프로세스가 동시에 실행되고 있는 것 처럼 느끼고 이것을 멀티태스킹이라 부른다.

https://oizys.tistory.com/14

https://nstgic3.tistory.com/40



#### 5. Thread 간의 데이터 공유와 Process 간의 데이터 공유의 공통점과 차이점

**A. 공유 메모리 shared memory**

커널의 통신 서비스를 이용해 협력하는 프로세스들 사이에 공유되는 메모리 영역(shared memory)을 구축하는 방법이다. **메모리를 직접 접근하기 때문에 속도가 빠르고 사용이 편리하다.**

문제점 : 프로세스A가 공유 메모리에 데이터 전달해도 프로세스B가 그것을 알 수 없다 => **별도의 동기화 기술이 필요하다.**



 공유 메모리 (shared memory)

공유 메모리 방식에서는 프로세스들이 주소 공간의 일부를 공유하는데, 이 공유한 메모리 영역에 read/write를 통해서 통신을 수행한다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해준다. 공유 메모리 영역이 구축된 이후에는 모든 접근이 일반적인 메모리 접근으로 취급되기 때문에 더 이상 커널의 도움없이도 각 프로세스들이 해당 메모리 영역에 접근할 수 있다.



공유 메모리 방식은 프로세스간의 통신을 수월하게 만들지만, 동시에 같은 메모리 위치에 접근하게 되면 `일관성 문제`가 발생할 수 있다. 커널은 이 부분에 대허 관여하지 않기 때문에 프로세스끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져아 한다.



**B. message passing** 

운영체제 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메시지 형태로 정보를 Send/Receive 하는 방법이다. **커널에서 데이터의 주고 받음을 컨트롤할 수 있어 별도의 동기화 로직이 없어도 된다.**  하지만 커널을 통해서 데이터 주고 받기 때문에 **성능 문제가 있을 수 있다.**



### 메시지 전달 (message passing)

메시지 전달 방법은 통산 system call을 사용하여 구현된다. 커널을 통해 send(message)와 receive(message)라는 두 가지 연산을 제공받는다. 예를 들어 프로세스1이 커널로 메시지를 보내면, 커널이 프로세스2에게 메시지를 보내주는 방식으로 동작한다.



메모리 공유보다는 속도가 느리지만, `충돌을 회피할 필요가 없기` 때문에 적은양의 데이터를 교환하는 데 유용하며, 구현(대표적으로 pipe, socket, message queue 등)하기가 쉽다는 장점을 갖는다.



동일 프로세스 내부의 스레드들은 공유 메모리 영역이 존재한다. 

지역변수, 전역변수를 통해 데이터 공유가 가능하다. 



#### 6. 컴파일러와 인터프리터는 어떤 차이가 있을까요 ?

컴파일러(compiler)

- 전체 파일을 스캔하여 한꺼번에 번역한다.
- 초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.
- 기계어 번역과정에서 더 많은 메모리를 사용한다.
- 전체 코드를 스캔하는 과정에서 모든 오류를 한꺼번에 출력해주기 때문에 실행 전에 오류를 알 수 있다.
- 대표적인 언어로 C, C++, JAVA 등이 있다.

인터프리터(interpreter)

- 프로그램 실행시 한 번에 한 문장씩 번역한다.
- 한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.
- 컴파일러와 같은 오브젝트 코드 생성과정이 없기 때문에 메모리 효율이 좋다.
- 프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있다.
- 대표적인 언어로 Python, Ruby, Javascript 등이 있다.



- 자바는 인터프리터와 컴파일러 둘 다 섞여있다. 

